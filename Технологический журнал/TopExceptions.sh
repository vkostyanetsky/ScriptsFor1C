# Скрипт анализирует технологический журнал и выводит топ ошибок в формате «количество срабатываний + описание». 

# Читаем все логи в директории, где вызван скрипт. Если нужно, можно читать логи конкретных процессов:
# например, cat rp*/*.log прочитает только логи rphost'ов.
#
cat */*.log | 

# На этом этапе удобно удалить информацию, которая не нужна для анализа — тогда некоторые ошибки могут быть сгруппированы.
# Например, замена ниже превратит строки «server_addr=(23)[::1]:49427» в «server_addr=(00)[::0]:00000».
#
sed -r "s/server_addr=\(.*:[0-9]+/server_addr=(00)[::0]:00000/g" |

# Теперь нам нужно найти события исключений (EXCP), прочитать из них описание (Descr) и определить, сколько раз
# среди исключений попадается каждое описание. С этой задачей хорошо справляется gawk. 
#
# Установим настройки. Во-первых, каждое событие начинается с времени (например, 14:55.636001-). Сделаем
# такую подстроку разделитем записей. Теперь каждая запись будет содержать событие полностью (со всеми 
# переводами строк и другими спецсимволами).
# 
# Во-вторых, описание ошибки — если оно есть — помещается в строке события последним, после подстроки «Descr=».
# Сделаем её разделителем полей. Теперь каждая запись будет иметь два поля: первое — cтрока события до описания,
# второе — собственно, описание.
#
# Скрипт работает в два этапа. На первом мы коллекционируем уникальные значения описания для события исключения
# и считаем, сколько раз каждое описание было найдено. На втором — для каждого найденного уникального описания
# выводим количество найденных совпадений и текст описания.
#
# FIXME В некоторых случаях скрипт не группирует пустые описания. Вероятно, какие-то спецсимволы мешают, нужно разобраться.
#
gawk -F'Descr=' -vRS='[0-9]+:[0-9]+.[0-9]+-' '
{  
    if ( $1 ~ "^.*,EXCP,.*" ) {
        gsub("\n", "<LF>", $2);
        descriptions[$2] += 1;
    }
};

END {
    for (description in descriptions)
        print descriptions[description] " " description
}' |
    
# На этот момент у нас есть что-то вроде:
#
# 3 Ошибка совместного доступа к файлу
# 8 Конфликт блокировок при выполнении транзакции
# 1 Файл не обнаружен
#
# Утилита sort легко справится с сортировкой, интерпретируя строки как числа. Выводим итог в обратном порядке,
# чтобы получить топ — в начале будут выведены сначала самые частотные события.
#
sort -rnb |

# Когда мы собирали уникальные описания ошибок и считали их количество, мы заменяли переводы строк в описаниях
# на подстроку <LF> — чтобы в дальнейшем результат можно было отсортировать утилитой sort.
#
# Поскольку сортировка проделана, можно сделать обратную замену — тогда результат будет удобнее читать.
#
sed -r "s/<LF>/\n/g" > TopExceptions.txt