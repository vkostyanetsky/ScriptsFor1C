# Скрипт анализирует технологический журнал и выводит топ запросов к MSSQL. Запросы группируются по тексту запроса и его контексту;
# для каждого выводится общее время выполнения, среднее время выполнение и количество выполнений. Сортировка — по общему времени.

# Читаем логи rphost'ов.
#
cat rphost_*/*.log |

# Сразу удаляем строки с параметрами запросов — они помешают нормальной группировке.
# По уму, это нужно делать внутри скрипта gawk, но я не придумал, как прикрутить
# к gsub() ленивый квантификатор.
#
sed -r "/^p_[0-9]+:/d" |

# Скрипт разделяет лог по метке времени события и работает только с событияеми DBMSSQL.
# Каждое событие разделяется по подстроке «Sql=»; таким образом, в первом поле у нас будет
# строка события до текста запроса, во втором поле — Sql, Rows, RowsAffected и Context.
#
# Из первого поля нам нужна только продолжительность события (т.е. время выполнения запроса).
# Его можно получить через split(), который разделит строку по запятым. Строка до первой запятой
# и есть длительность, так как время начала события мы уже удалили при разделении записей.
#
# Во втором поле нас интересует только текст запроса и контекст. Поэтому остальные два параметрам
# мы удаляем, а также заменяем имена временных таблиц на одно универсальное (улучшит группировку)
# и заменяем переводы строк на подстроку <LF> (если этого не сделать — сортировать будет неудобно).
#
# Скрипт делится на две части; первая собирает данные в массивы QueriesDuration и QueriesExecuted.
# Первый храрнит общую длительность запросов, второй — количество их выполнений. Ключи каждого — 
# текст запроса и его контекст.
#
# Завершающая часть скрипта считает общую и среднюю продолжительность запросов в секундах, 
# форматирует и выводит.
#
gawk -F'Sql=' -vRS='[0-9]+:[0-9]+.[0-9]+-' '
{    
    if ( $1 ~ "^.*,DBMSSQL.*" ) {
       
        split($1, parts, ",");
       
        gsub("\n", "<LF>", $2);
        gsub("#tt[0-9]+", "#tt", $2);
        gsub("Rows=[0-9]+,RowsAffected=[0-9]+,", "", $2);

        QueriesDuration[$2] += parts[1];
        QueriesExecuted[$2] += 1;
    }
};
END {

    for (Query in QueriesDuration) {
    
        executedTotal   = QueriesExecuted[Query]
        durationTotal   = QueriesDuration[Query] / 1000000;
        durationAverage = QueriesDuration[Query] / QueriesExecuted[Query] / 1000000;
        
        printf "%.3f seconds total, %.3f seconds on average, %d executions<LF>%s\n", durationTotal, durationAverage, executedTotal, Query;
        
    }
        
}
' |

# Сортировка и отсечение первой сотни результатов.
#
sort -rn |
head -n 100 |

# Мы заменяли переводы строк на подстроку <LF>, чтобы в дальнейшем результат можно было отсортировать утилитой sort.
#
# Поскольку сортировка проделана, можно сделать обратную замену — тогда результат будет удобнее читать.
#
sed -r "s/<LF>/\n/g" > TopQueries.txt