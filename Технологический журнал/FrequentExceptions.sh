# Топ частотных ошибок на базе события EXCP.
#
# Для каждого исключения выводится количество срабатываний и описание.
#
# Более простые варианты решения той же задачи:
#
# grep -ho ",EXCP,.*Descr=.*" */*.log | perl -pe "s/,EXCP,.,.*Descr=/Descr=/g" | uniq -c | sort -rn
# grep -hoP ",EXCP,.*\KDescr=.*" */*.log | uniq -c | sort -rn
#
# Проблема с ними том, что описание у EXCP может быть многострочным — то есть, варианты выше
# будут терять часть данных, нужных для расследования проблемы.

cat */*.log | 

# Удаляем из потока данных UTF-8 BOM.
#
perl -pe 's/\xef\xbb\xbf//g' |

# На этом этапе удобно удалить информацию, которая не нужна для анализа — тогда некоторые ошибки могут быть сгруппированы.
# Например, замена ниже превратит строки «server_addr=(23)[::1]:49427» в «server_addr=(00)[::0]:00000».
#
sed -r "s/server_addr=\(.*:[0-9]+/server_addr=(00)[::0]:00000/g" |

# Теперь нам нужно найти события исключений (EXCP), прочитать из них описание (Descr) и определить, сколько раз
# среди исключений попадается каждое описание. С этой задачей хорошо справляется gawk. 
#
# Установим настройки. Во-первых, каждое событие начинается с времени (например, 14:55.636001-). Сделаем
# такую подстроку разделитем записей. Теперь каждая запись будет содержать событие полностью (со всеми 
# переводами строк и другими спецсимволами).
# 
# Во-вторых, описание ошибки — если оно есть — помещается в строке события последним, после подстроки «Descr=».
# Сделаем её разделителем полей. Теперь каждая запись будет иметь два поля: первое — cтрока события до описания,
# второе — собственно, описание.
#
# Скрипт работает в два этапа. На первом мы коллекционируем уникальные значения описания для события исключения
# и считаем, сколько раз каждое описание было найдено. На втором — для каждого найденного уникального описания
# выводим количество найденных совпадений и текст описания.
#
gawk -F'Descr=' -vRS='[0-9]+:[0-9]+.[0-9]+-' '

function Description(StringAfterDescription)
{
    gsub("\n+$", "", StringAfterDescription);
    gsub("\n", "<LF>", StringAfterDescription);

    return StringAfterDescription;
}

{  
    if ( $1 ~ "^.*,EXCP,.*" ) {

        Grouping = Description($2); 
        Quantity[Grouping] += 1;

    }
};

END {
    for (Grouping in Quantity)
        print Quantity[Grouping] " " Grouping "<LF>"
}' |
    
sort -rn |
head -n 100 |

# Мы заменили переводы строк на подстроку <LF> — чтобы результат можно было отсортировать (sort)
# и усечь (head). Теперь можно сделать обратную замену.
#
sed -r "s/<LF>/\n/g" > FrequentExceptions.txt